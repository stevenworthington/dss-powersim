[["index.html", "Simulation-Based Power Analysis Table of Contents Contributors", " Simulation-Based Power Analysis This tutorial is designed to be a quick-start guide for conducting simulation-based power analyses in R, Python, and Stata. We focus particularly on power for mixed effects models, but the principles employed can be repurposed for any model and study design. The tutorial is suitable for anyone with a intermediate understanding of mixed effects models and coding in either R, Python, or Stata. While high-level packages exist in some of these languages for conducting simulation-based power analysis (e.g., the R packages {simr}, {longpower}, and {simglm}), such packages abstract away the details of conducting simulations and thus are best used after gaining an understanding of the power simulation process. In addition, rolling your own simulations from scratch provides much more flexibility to tackle different study designs and models - and it’s fun! We are always grateful for any feedback you are willing to provide about our tutorials! Please email help@iq.harvard.edu with any thoughts. Table of Contents Canned Power Analysis Simulation-based Power Analysis Power of What? R Examples Python Examples Stata Examples Software Comparison Resources   Contributors The contents of these workshops are the result of a collaborative effort from members of the Data Science Services team at the Institute for Quantitative Social Science at Harvard University. The main contributors are Steve Worthington and Dan Yuan, with additional feedback from Jinjie Liu and Noah Greifer. "],["power-analysis.html", "1 Power Analysis 1.1 Canned routines 1.2 Step by step", " 1 Power Analysis Statistical power is the probability of rejecting a null hypothesis when it is false, or equivalently, of detecting an effect if such an effect exists. 1.1 Canned routines For some studies, it can be an important step to calculate a priori statistical power. We use statistical power to determine the probability of rejecting a null hypothesis when it is false, or equivalently, of detecting an effect if such an effect exists. \\[ \\begin{align} \\textrm{Power} &amp;= \\textrm{Pr}(\\textrm{reject} \\, H_0 \\, | \\, H_0 \\, \\textrm{is false}) \\\\ &amp;= 1 - \\textrm{Pr}(\\textrm{fail to reject} \\, H_0 \\, | \\, H_0 \\, \\textrm{is false}) \\\\ &amp;= 1 - \\beta \\end{align} \\] We want \\(\\beta\\) (Type II error) to be small and power to be large. When designing a study, rather than calculating power when sample size and effect size are fixed, researchers typically want to know the sample size required to reject a null hypothesis at a given level of power and effect size. In some situations, where the study design and/or model of interest is fairly simple, we can use a formula to calculate the sample size required to reject a null hypothesis. We will use a simple example to show the process involved. For instance, if we plan to perform a test of an hypothesis comparing the cholesterol levels of people in two populations, one with a diet comprising low oat consumption and the other with high oat consumption, we could specify the following null and alternative hypotheses, respectively: \\[ \\begin{align} \\textrm{H}_0 : \\mu_1 - \\mu_2 &amp;= 0 \\\\ \\textrm{H}_1 : \\mu_1 - \\mu_2 &amp;\\neq 0 \\end{align} \\] where \\(\\mu_1\\) and \\(\\mu_2\\) are the mean cholesterol levels in the two populations being compared. We can use a formula to determine the sample sizes required so that the test has a specific power. We will need the following inputs to the formula: \\(\\alpha\\) (Type I error / significance level): typically, this is set to \\(0.05\\) in most studies. \\(1 - \\beta\\) (power): often this is set to \\(0.8\\) or \\(0.9\\). \\(\\sigma\\) (population standard deviation): we need to estimate/guess this. \\(\\delta\\) (alternative hypothesis): ideally the smallest difference \\(\\delta = \\mu_1 - \\mu_2\\) that has scientific or clinical importance. Given \\(\\alpha\\), \\((1 - \\beta)\\), \\(\\sigma\\), and \\(\\delta\\), we can calculate \\(n_g\\) the sample size in each group to reject \\(\\textrm{H}_0\\) with probability \\((1 - \\beta)\\). To simplify things a little, we will use the normal distribution as an approximation to the \\(t\\) distribution (which should be fine when \\(n_g \\geq 30\\)). Here is the formula for this approximate two-sample \\(t\\)-test: \\[ n_g \\approx 2(z_{\\alpha / 2} + z_\\beta)^2 \\left( \\frac{\\sigma}{\\delta} \\right)^2 \\] where \\(n_g\\) is the sample size required in each group, \\(z_{\\alpha/2}\\) is the value from the standard normal distribution holding half the selected \\(\\alpha\\) level below it (because this is a two-tailed test), \\(z_\\beta\\) is the value from the standard normal distribution holding the \\(\\beta\\) level below it, \\(\\delta\\) is the effect size (the difference in population averages \\(\\mu_1 - \\mu_2\\) of cholesterol), and \\(\\sigma\\) is the pooled population standard deviation (during study planning we usually assume equal variances in the two groups). Typically, we would set \\(\\alpha\\) and \\(\\beta\\) to the following values and rely on previous studies or pilot data to obtain reasonable values for \\(\\sigma\\) and \\(\\delta\\): \\(\\alpha = 0.05\\), so \\(z_{\\alpha / 2} = 1.960\\). \\(1 - \\beta = 0.8\\), so \\(\\beta = 0.2\\), so \\(z_\\beta = 0.8416\\). \\(\\sigma = 1\\); this could be our best guess based on previous studies. \\(\\delta = 0.7\\), our best guess based on previous studies could be that mean differences of 0.7 mmol/L or greater should be considered biologically important. We can then plug these input values into our formula: \\[ n_g \\approx 2(1.960 + 0.8416)^2 \\left( \\frac{1}{0.7} \\right)^2 = 32.036 \\] We always round up to a whole number for sample size, so for this study we need 33 subjects per group, or \\(n=66\\) in total. In practice, we will often rely on software to perform the above calculation for us. In R we can use the power.t.test() function from the built-in {stats} package to calculate the sample size needed to reject the null hypothesis that \\(\\textrm{H}_0 : \\mu_1 - \\mu_2 = 0\\). We just need to pass the \\(n\\) parameter as NULL to tell R that we’d like to calculate sample size based on the values of the other parameters: power.t.test(n=NULL, delta=0.7, sd=1, sig.level=0.05, power=0.8, alternative=&quot;two.sided&quot;) ## ## Two-sample t test power calculation ## ## n = 33.02467 ## delta = 0.7 ## sd = 1 ## sig.level = 0.05 ## power = 0.8 ## alternative = two.sided ## ## NOTE: n is number in *each* group 1.2 Step by step Here are the general set of steps required to implement a power analysis for most study designs: 1. Specify a hypothesis test. Make explicit a null and alternative hypothesis. 2. Specify Type I and Type II error levels for the test. Typically, the Type I error level (significance level / false positive level) is set to \\(\\alpha=0.05\\) and Type II error level (false negative level) \\(\\beta=0.2\\), which yields a power level of \\(1 - \\beta = 0.8\\), but other values could be substituted instead. 3. Specify the estimated effect size level for the test. To solve for sample size \\(n\\), we need an estimate of effect size (\\(\\delta = \\mu_1 - \\mu_2\\)) that has scientific meaning. Sometimes we need to use a pilot dataset or look to previous studies to get this value. 4. Calculate the sample size required to obtain the power level desired. This can either be done by pugging and chugging values into the relevant formula, or by using a software-based implementation of said formula. "],["simulation.html", "2 Simulation 2.1 Customization 2.2 Step by step", " 2 Simulation 2.1 Customization Formulas often do not exist to calculate power for the effect of interest and therefore canned functions/programs/macros may not be available. For some studies, such as those involving complex study designs or those using mixed effects models for inference, we must therefore rely on simulation to provide a means of generating estimates of power that are customized for our current situation. The basic idea is to simulate running our study many times and calculate the proportion of times we reject the null hypothesis. This proportion provides an estimate of power. Generating a dataset and running an analysis for the hypothesis test is part of the simulation. Randomness is introduced into the process during dataset generation. For example, say the desired power level is 90%, and you want to calculate the sample size required to obtain this level of power. We could use the “guess sample size and check power” method. Firstly, choose a sample size \\(n_1\\) and run the simulation to estimate power. If power is estimated to be lower than 90%, select a new value \\(n_2\\) that is larger than \\(n_1\\) and run the simulation again. Simulation runs are repeated until the estimated power is roughly 90%. 2.2 Step by step There are two broad steps involved in conducting simulation-based power analysis: 1) thinking and, 2) implementing. Think Model specification: Write down the regression model, including all variables and parameters of interest. Variable composition: Specify the form of the explanatory variables, such as the range of age or BMI, proportion of females/males, or the coding scheme used for categorical terms. Parameter composition: Establish reasonable values for the data-generating parameters in your model. Implement Simulate: Simulate the sampling process for a single dataset, assuming the alternative hypothesis, and fit the model of interest. Automate: Write a function/program/macro to automate the process of creating datasets, fitting models, testing the hypothesis of interest, and calculating power for that test - the number of significant simulations out of the total number of simulations. The function/program/macro should be flexible enough to allow for iterating power calculations over a grid of different parameter values. Summarize: Summarize the relationships between power, sample size, and effect size in tables and figures. The implementation phase can be summarized by the following graphic: "],["power-of-what.html", "3 Power of What? 3.1 Study design 3.2 Mixed effects model", " 3 Power of What? The initial steps of power simulation involve nothing more than thinking and writing down your thoughts using a pencil and paper. But, prior to walking through these steps, there is an even more fundamental issue to be addressed - the power of what? What quantity within our model do we wish to calculate power for? Overall model goodness-of-fit, individual parameters, or combinations of parameters? The point of entry for power analysis is always to identify the particular effect of interest, and for that we must answer the question: “power of what?” 3.1 Study design The study design we will use as an example throughout this tutorial comes from Julian Quandt’s blogpost (https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-iv/). He describes this as: A new hypothetical research question focused on music preference. The overarching research goal will be to find out whether Rock or Pop music is better. Of course, we could just ask people what they prefer, but we want a more objective measure of what is Rock and Pop (people might have different ideas about the genres). Therefore, we will have participants listen to a bunch of different songs that are either from a Spotify “best-of-pop” or “best-of-rock” playlist and have them rate each song on an evaluation scale from 0-100 points. 3.2 Mixed effects model Canned routines exist to perform power analysis for some simple general linear models (GLMs), however, for generalized linear mixed effects models (GLMMs) we must rely on simulation. We will walk through the process of simulating data for a GLMM in a step-by-step manner, which will serve as scaffolding to build intuition about how to conduct power simulation. Once we have the workflow down, we can automate the simulation process using functions. While the outcome in this example is bounded on the interval [0, 100], we will not concern ourselves with the issue of using a linear model with such an outcome. 3.2.1 Step 1: model specification The first step in simulation-based power analysis is to write down the regression model of interest, including all variables and parameters: \\[ \\textrm{liking}_{ij} = \\beta_0 + T_{0j} + O_{0i} + (\\beta_1 + T_{1j}) \\times \\textrm{genre}_i + \\epsilon_{ij} \\] where the subscripts \\(i\\) and \\(j\\) denote individual songs and participants, respectively, liking is an integer-based rating of a given song on the interval [0, 100], genre is a dummy coded binary variable indicating whether the song is classified as “rock” or “pop”, and we assume \\(T_{0j} \\sim \\mathcal{N}(0, \\tau_0)\\), \\(T_{1j} \\sim \\mathcal{N}(0, \\tau_1)\\), \\(O_{0i} \\sim \\mathcal{N}(0, \\omega_0)\\), and \\(\\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma)\\). The parameter of interest is \\(\\beta_1\\) - the average (within-subject) difference in the rating of songs between the two genres. Table 3.1 lists all of the variables and parameters in the model. Table 3.1: Variables in the data-generating model and associated code-based names. model code description \\(\\textrm{liking}_{ij}\\) \\(\\texttt{liking_ij}\\) rating of song \\(i\\) for participant \\(j\\) on the interval [0, 100] \\(\\textrm{genre}_i\\) \\(\\texttt{genre_i}\\) genre of song \\(i\\) (0=‘pop’, 1=‘rock’) \\(\\beta_0\\) \\(\\texttt{beta_0}\\) intercept; mean of liking rating for ‘pop’ genre \\(\\beta_1\\) \\(\\texttt{beta_1}\\) slope; mean difference btw ‘pop’ and ‘rock’ song ratings \\(\\tau_0\\) \\(\\texttt{tau_0}\\) standard deviation of by-subject random intercepts \\(\\tau_1\\) \\(\\texttt{tau_1}\\) standard deviation of by-subject random slopes \\(\\rho\\) \\(\\texttt{rho}\\) correlation between by-subject random intercepts and slopes \\(\\omega_0\\) \\(\\texttt{omega_0}\\) standard deviation of by-song random intercepts \\(\\sigma\\) \\(\\texttt{sigma}\\) standard deviation of residuals \\(T_{0j}\\) \\(\\texttt{T_0j}\\) random intercept for subject \\(j\\) \\(T_{1j}\\) \\(\\texttt{T_1j}\\) random slope for subject \\(j\\) \\(O_{0i}\\) \\(\\texttt{O_0i}\\) random intercept for song \\(i\\) \\(e_{ij}\\) \\(\\texttt{e_ij}\\) residual of song \\(i\\) for participant \\(j\\) 3.2.2 Step 2: Variable composition Once we have the model equation, we need to specify the details of the explanatory variables. In our model, we only have a single binary predictor, so the only decision to make is which coding scheme to use: dummy coding, zero sum coding, or something else. Here, we chose dummy coding, since our primary interest is in the difference between the “rock” and “pop” genres. In many other situations, we might include variables such as age and sex in the model. In which case we would need to determine reasonable settings for the range of age and the proportion of females to males. For example, the range of age might encompass the full possible range of human longevity (e.g., 0 to 120 years) or could be more focused on non-retired adults (e.g., 18 to 65 years). The proportion of females to males could theoretically vary anywhere in the interval (0, 1), but practically is rarely outside of the interval [0.45, 0.55]. 3.2.3 Step 3: Parameter composition Finally, we need to establish the data-generating parameters in the model. You may draw on your own, or your colleague’s, substantive expertise about the phenomenom you’re studying to determine what paramater values are plausible. Or, you might look to the literature for studies that examined similar effects. Table 3.2 lists parameter values we will use as a starting point. Later, we will try using some alternative values and compare power for each. Table 3.2: Settings for all data-generating parameters. code value description \\(\\texttt{beta_0}\\) 60 intercept; i.e., mean of liking rating for ‘pop’ genre \\(\\texttt{beta_1}\\) 5 slope; i.e, mean difference btw ‘pop’ and ‘rock’ song ratings \\(\\texttt{tau_0}\\) 7 by-subject random intercept sd \\(\\texttt{tau_1}\\) 4 by-subject random slope sd \\(\\texttt{rho}\\) 0.2 correlation between intercept and slope \\(\\texttt{omega_0}\\) 3 by-song random intercept sd \\(\\texttt{sigma}\\) 8 residual (error) sd "],["r.html", "4 R 4.1 Setup 4.2 Data simulation step by step 4.3 Data simulation automated 4.4 Power calculation single run 4.5 Power calculation automated 4.6 Power for different effect sizes", " 4 R 4.1 Setup We will need to use several R packages to optimize our workflow and fit mixed effects models. We can use the p_load() function from the {pacman} library to automate installing these packages onto our machine and then load them into our search path. # uncomment the line below to install the {pacman} library on your computer # install.packages(&quot;pacman&quot;) pacman::p_load( lme4, # model specification / estimation lmerTest, # provides p-values in the model output future, # parallelization future.apply, # fast automation furrr, # fast functional programming faux, # simulate from multivariate normal distribution broom.mixed, # extracting tidy data from model fits tidyverse, # data wrangling and visualisation gt # nice tables ) faux_options(verbose = FALSE) We will also set the pseudo-random number generator seed to 02138 to make the stochastic components of our simulations reproducible. set.seed(02138) Finally, let’s take advantage of background parallelization to speed-up iterative processes. plan(multisession) 4.2 Data simulation step by step To give an overview of the power simulation task, we will simulate data from a design with crossed random factors of subjects and songs (see Power of What? for design details), fit a model to the simulated data, recover from the model output the parameter values we put in, calculate power, and finally automate the whole process so that we can calculate power for different effect sizes. Much of the general workflow here is borrowed from DeBruine &amp; Dale (2021) Understanding Mixed-Effects Models through Simulation. We’ll start by writing code that simulates datasets under the alternative hypothesis. 4.2.1 Establish the simulation parameters Before we start, let’s set some global parameters for our power simulations. Since simulations can take a long time to run, we’ll use 100 replications here as an example, but we recommend increasing this number to at least 1000 replications for a more accurate final power calculation. # number of simulation replicates for power calculation reps &lt;- 100 # specified alpha for power calculation alpha &lt;- 0.05 4.2.2 Establish the data-generating parameters The first thing to do is to set up the parameters that govern the process we assume gave rise to the data - the data-generating process, or DGP. We previously decided upon the the data-generating parameters (see Power of What?), so we just need to code them here. # set all data-generating parameters beta_0 &lt;- 60 # intercept; i.e., the grand mean beta_1 &lt;- 5 # slope; i.e, effect of category omega_0 &lt;- 3 # by-song random intercept sd tau_0 &lt;- 7 # by-subject random intercept sd tau_1 &lt;- 4 # by-subject random slope sd rho &lt;- 0.2 # correlation between intercept and slope sigma &lt;- 8 # residual (error) sd 4.2.3 Simulate the sampling process Next, we will simulate the sampling process for the data. First, let’s define parameters related to the number of observations. # set number of subjects and songs n_subj &lt;- 25 # number of subjects n_pop &lt;- 15 # number of songs in pop category n_rock &lt;- 15 # number of songs in rock category 4.2.3.1 Simulate the sampling of songs We need to create a table listing each song \\(i\\), which category it is in (rock or pop), and its random effect \\(O_{0i}\\). The latter is sampled from a univariate normal distribution using the function rnorm(). # simulate a sample of songs songs &lt;- tibble( song_id = seq_len(n_pop + n_rock), category = rep(c(&quot;pop&quot;, &quot;rock&quot;), c(n_pop, n_rock)), genre_i = rep(c(0, 1), c(n_pop, n_rock)), O_0i = rnorm(n = n_pop + n_rock, mean = 0, sd = omega_0) ) print(songs) ## # A tibble: 30 × 4 ## song_id category genre_i O_0i ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 pop 0 0.0930 ## 2 2 pop 0 -0.960 ## 3 3 pop 0 -2.40 ## 4 4 pop 0 -5.11 ## 5 5 pop 0 3.64 ## 6 6 pop 0 1.37 ## 7 7 pop 0 -8.10 ## 8 8 pop 0 -0.382 ## 9 9 pop 0 -3.41 ## 10 10 pop 0 5.14 ## # ℹ 20 more rows 4.2.3.2 Simulate the sampling of subjects Now we simulate the sampling of participants, which results in table listing each individual and their two correlated random effects (a random intercept and random slope). To do this, we must sample \\({T_{0j}, T_{1j}}\\) pairs - one for each subject - from a bivariate normal distribution. We will use the function faux::rnorm_multi(), which generates a table of n simulated values from a multivariate normal distribution by specifying the means (mu) and standard deviations (sd) of each variable, plus the correlations (r), which can be either a single value (applied to all pairs), a correlation matrix, or a vector of the values in the upper right triangle of the correlation matrix. # simulate a sample of subjects # sample from a multivariate normal distribution subjects &lt;- faux::rnorm_multi( n = n_subj, mu = 0, # means for random effects are always 0 sd = c(tau_0, tau_1), # set SDs r = rho, # set correlation varnames = c(&quot;T_0j&quot;, &quot;T_1j&quot;) ) |&gt; mutate(subj_id = seq_len(n_subj)) # add subject IDs print(subjects) ## T_0j T_1j subj_id ## 1 -2.3346510 0.1687614 1 ## 2 0.3959453 1.9622098 2 ## 3 -8.4780483 0.7164860 3 ## 4 -13.8131963 -5.0491497 4 ## 5 -3.5060380 -1.1569376 5 ## 6 -2.1212439 -4.9908990 6 ## 7 9.4437300 6.9991910 7 ## 8 3.9611598 3.0543689 8 ## 9 -11.5109648 -3.2891498 9 ## 10 4.7555765 -5.6778769 10 ## 11 -14.1816592 -0.7967538 11 ## 12 8.0029214 4.2205505 12 ## 13 -1.5538324 4.4132587 13 ## 14 -10.3679040 2.3872260 14 ## 15 16.9451885 2.2781727 15 ## 16 6.4422603 8.1231748 16 ## 17 6.0274310 0.1527643 17 ## 18 9.7576581 3.2542338 18 ## 19 -2.3736184 4.0403367 19 ## 20 7.3783324 4.8779376 20 ## 21 -2.6966956 -4.2765738 21 ## 22 4.5647259 2.4437034 22 ## 23 2.4010082 8.6862440 23 ## 24 1.7570425 1.3291182 24 ## 25 -3.0887187 -2.7631663 25 4.2.3.3 Check the simulated values Let’s do a quick sanity check by comparing our simulated values to the parameters we used as inputs. Because the sampling process is stochastic, we shouldn’t expect that these will exactly match for any given run of the simulation. tibble( parameter = c(&quot;omega_0&quot;, &quot;tau_0&quot;, &quot;tau_1&quot;, &quot;rho&quot;), value = c(omega_0, tau_0, tau_1, rho), simulated = c( sd(songs$O_0i), sd(subjects$T_0j), sd(subjects$T_1j), cor(subjects$T_0j, subjects$T_1j) ) ) ## # A tibble: 4 × 3 ## parameter value simulated ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 omega_0 3 3.00 ## 2 tau_0 7 7.87 ## 3 tau_1 4 4.05 ## 4 rho 0.2 0.495 4.2.3.4 Simulate trials Since all subjects rate all songs (i.e., the design is fully crossed) we can set up a table of trials by including every possible combination of the rows in the subjects and songs tables. Each trial has random error associated with it, reflecting fluctuations in trial-by-trial ratings due to unkown factors. We simulate this by sampling values from a univariate normal distribution with a mean of 0 and a standard deviation of sigma. # cross subject and song IDs; add an error term trials &lt;- crossing(subjects, songs) |&gt; mutate(e_ij = rnorm(n(), mean = 0, sd = sigma)) print(trials) ## # A tibble: 750 × 8 ## T_0j T_1j subj_id song_id category genre_i O_0i e_ij ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -14.2 -0.797 11 1 pop 0 0.0930 -2.07 ## 2 -14.2 -0.797 11 2 pop 0 -0.960 5.46 ## 3 -14.2 -0.797 11 3 pop 0 -2.40 5.79 ## 4 -14.2 -0.797 11 4 pop 0 -5.11 -2.02 ## 5 -14.2 -0.797 11 5 pop 0 3.64 16.5 ## 6 -14.2 -0.797 11 6 pop 0 1.37 3.92 ## 7 -14.2 -0.797 11 7 pop 0 -8.10 11.9 ## 8 -14.2 -0.797 11 8 pop 0 -0.382 -6.91 ## 9 -14.2 -0.797 11 9 pop 0 -3.41 -6.68 ## 10 -14.2 -0.797 11 10 pop 0 5.14 -2.11 ## # ℹ 740 more rows 4.2.3.5 Calculate response values With this resulting trials table, in combination with the constants beta_0 and beta_1, we have the full set of values that we need to compute the response variable liking_ij according the linear model we defined previously (see Power of What?). dat_sim &lt;- trials |&gt; mutate(liking_ij = beta_0 + T_0j + O_0i + (beta_1 + T_1j) * genre_i + e_ij) %&gt;% select(subj_id, song_id, category, genre_i, liking_ij) print(dat_sim) ## # A tibble: 750 × 5 ## subj_id song_id category genre_i liking_ij ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 1 pop 0 43.8 ## 2 11 2 pop 0 50.3 ## 3 11 3 pop 0 49.2 ## 4 11 4 pop 0 38.7 ## 5 11 5 pop 0 66.0 ## 6 11 6 pop 0 51.1 ## 7 11 7 pop 0 49.7 ## 8 11 8 pop 0 38.5 ## 9 11 9 pop 0 35.7 ## 10 11 10 pop 0 48.8 ## # ℹ 740 more rows 4.2.3.6 Plot the data Let’s visualize the distribution of the response variable for each of the two song genres and superimpose the simulated parameter estimates for the means of these two groups. dat_sim |&gt; ggplot(aes(category, liking_ij, color = category)) + # predicted means geom_hline(yintercept = (beta_0 + 0*beta_1), color = &quot;orange&quot;, linetype = &quot;dashed&quot;, linewidth = 1) + geom_hline(yintercept = (beta_0 + 1*beta_1), color = &quot;dodgerblue&quot;, linetype = &quot;dashed&quot;, linewidth = 1) + # actual data geom_violin(alpha = 0.5, show.legend = FALSE, fill = &quot;grey65&quot;) + stat_summary(fun = mean, geom=&quot;crossbar&quot;, show.legend = FALSE) + scale_color_manual(values = c(&quot;orange&quot;, &quot;dodgerblue&quot;)) + ggtitle(&quot;Predicted versus simulated values&quot;) + theme_bw() 4.2.4 Analyze the simulated data Now we can analyze our simulated data in a linear mixed effects model using the function lmer() from the {lmerTest} package (which is a wrapper around the lmer() function from the {lme4} package that additionally provides \\(p\\)-values). The model formula in lmer() maps onto how we calculated our liking_ij outcome variable above. form &lt;- formula(liking_ij ~ 1 + genre_i + (1 | song_id) + (1 + genre_i | subj_id)) The terms in this R formula are as follows: liking_ij is the response. 1 is the intercept (beta_0), which is the mean of the response for the pop genre of songs (because we used dummy coding for the genre_i term). genre_i is the dummy coded variable identifying whether song \\(i\\) belongs to the pop or rock genre. (1 | song_id) specifies a song-specific random intercept (O_0i). (1 + genre_i | subj_id) specifies a subject-specific random intercept (T_0j) plus the subject specific random slope of the genre category (T_1j). Now we can estimate the model. # fit a linear mixed-effects model to data mod_sim &lt;- lmer(form, data = dat_sim) summary(mod_sim, corr = FALSE) ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: form ## Data: dat_sim ## ## REML criterion at convergence: 5392.5 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -3.00888 -0.66610 0.02982 0.64259 2.95212 ## ## Random effects: ## Groups Name Variance Std.Dev. Corr ## song_id (Intercept) 12.60 3.550 ## subj_id (Intercept) 57.18 7.562 ## genre_i 22.98 4.793 0.45 ## Residual 62.81 7.926 ## Number of obs: 750, groups: song_id, 30; subj_id, 25 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 58.474 1.815 37.775 32.216 &lt; 2e-16 *** ## genre_i 7.501 1.713 40.857 4.379 8.09e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 We can use the broom.mixed::tidy() function to get a tidy table of the results. This will prove to be super useful later when we need to combine the output from hundreds of simulations to calculate power. We will added columns for parameter and value, so we can compare the estimate from the model to the parameters we used to simulate the data. # get a tidy table of results broom.mixed::tidy(mod_sim) |&gt; mutate(across(is.numeric, round, 3)) |&gt; mutate( parameter = c(&quot;beta_0&quot;, &quot;beta_1&quot;, &quot;omega_0&quot;, &quot;tau_0&quot;, &quot;rho&quot;, &quot;tau_1&quot;, &quot;sigma&quot;), value = c(beta_0, beta_1, omega_0, tau_0, rho, tau_1, sigma), ) |&gt; select(term, parameter, value, estimate) |&gt; knitr::kable() term parameter value estimate (Intercept) beta_0 60.0 58.474 genre_i beta_1 5.0 7.501 sd__(Intercept) omega_0 3.0 3.550 sd__(Intercept) tau_0 7.0 7.562 cor__(Intercept).genre_i rho 0.2 0.451 sd__genre_i tau_1 4.0 4.793 sd__Observation sigma 8.0 7.926 4.3 Data simulation automated Now that we’ve tested the data generating code, we can put it into a function so that it’s easy to run it repeatedly. # set up the custom data simulation function sim_data &lt;- function( n_subj = 25, # number of subjects n_pop = 15, # number of pop songs n_rock = 15, # number of rock songs beta_0 = 60, # mean for pop genre beta_1 = 5, # effect of genre omega_0 = 3, # by-song random intercept sd tau_0 = 7, # by-subject random intercept sd tau_1 = 4, # by-subject random slope sd rho = 0.2, # correlation between intercept and slope sigma = 8 # residual (standard deviation) ) { # simulate a sample of songs songs &lt;- tibble( song_id = seq_len(n_pop + n_rock), category = rep(c(&quot;pop&quot;, &quot;rock&quot;), c(n_pop, n_rock)), genre_i = rep(c(0, 1), c(n_pop, n_rock)), O_0i = rnorm(n = n_pop + n_rock, mean = 0, sd = omega_0) ) # simulate a sample of subjects subjects &lt;- faux::rnorm_multi( n = n_subj, mu = 0, sd = c(tau_0, tau_1), r = rho, varnames = c(&quot;T_0j&quot;, &quot;T_1j&quot;) ) |&gt; mutate(subj_id = seq_len(n_subj)) # cross subject and song IDs crossing(subjects, songs) |&gt; mutate(e_ij = rnorm(n(), mean = 0, sd = sigma), liking_ij = beta_0 + T_0j + O_0i + (beta_1 + T_1j) * genre_i + e_ij) |&gt; select(subj_id, song_id, category, genre_i, liking_ij) } 4.4 Power calculation single run We can wrap the data generating function and modeling code in a new function single_run() that returns a tidy table of the analysis results for a single simulation run. We’ll suppress warnings and messages from the modeling fitting process, as these sometimes occur with simulation runs that generate extreme realized values for parameters. # set up the power function single_run &lt;- function(...) { # ... is a shortcut that forwards any additional arguments to sim_data() dat_sim &lt;- sim_data(...) mod_sim &lt;- suppressWarnings({ suppressMessages({ # suppress singularity messages lmerTest::lmer(liking_ij ~ 1 + genre_i + (1 | song_id) + (1 + genre_i | subj_id), data = dat_sim) })}) broom.mixed::tidy(mod_sim) } Let’s test that our new single_run() function performs as expected. # run one model with default parameters single_run() ## # A tibble: 7 × 8 ## effect group term estimate std.error statistic df p.value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 fixed &lt;NA&gt; (Intercept) 60.9 1.89 32.2 34.6 2.26e-27 ## 2 fixed &lt;NA&gt; genre_i 4.23 1.58 2.68 39.9 1.08e- 2 ## 3 ran_pars song_id sd__(Intercept) 3.27 NA NA NA NA ## 4 ran_pars subj_id sd__(Intercept) 8.24 NA NA NA NA ## 5 ran_pars subj_id cor__(Intercep… 0.678 NA NA NA NA ## 6 ran_pars subj_id sd__genre_i 4.37 NA NA NA NA ## 7 ran_pars Residual sd__Observation 7.73 NA NA NA NA # run one model with new parameters single_run(n_pop = 10, n_rock = 50, beta_1 = 2) ## # A tibble: 7 × 8 ## effect group term estimate std.error statistic df p.value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 fixed &lt;NA&gt; (Intercept) 57.0 1.97 29.0 44.9 1.05e-30 ## 2 fixed &lt;NA&gt; genre_i 1.54 1.76 0.873 57.3 3.86e- 1 ## 3 ran_pars song_id sd__(Intercept) 3.46 NA NA NA NA ## 4 ran_pars subj_id sd__(Intercept) 7.77 NA NA NA NA ## 5 ran_pars subj_id cor__(Intercep… 0.210 NA NA NA NA ## 6 ran_pars subj_id sd__genre_i 5.85 NA NA NA NA ## 7 ran_pars Residual sd__Observation 7.92 NA NA NA NA 4.5 Power calculation automated To get an accurate estimation of power, we need to run the simulation many times. Here we use the future_map_dfr() function to iterate over a sequence of integers denoting the replications we want to perform. sims &lt;- future_map_dfr(1:reps, ~ single_run()) We can finally calculate power for our parameter of interest beta_1(denoted in the tidy model output table as the term genre_i) by filtering to keep only that term and the calculating the proportion of times the \\(p\\)-value is below the alpha (0.05) threshold. # calculate mean estimates and power for specified alpha sims |&gt; filter(term == &quot;genre_i&quot;) |&gt; group_by(term) |&gt; summarise( mean_estimate = mean(estimate), mean_se = mean(std.error), power = mean(p.value &lt; alpha), .groups = &quot;drop&quot; ) ## # A tibble: 1 × 4 ## term mean_estimate mean_se power ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 genre_i 5.01 1.46 0.93 4.5.1 Check false positive rate We can do a sanity check to see if our simulation is performing as expected by checking the false positive rate (Type I error rate). We set the effect of genre_ij (beta_1) to 0 to calculate the false positive rate, which is the probability of concluding there is an effect when there is no actual effect in the population. # run simulations and calculate the false positive rate sims_fp &lt;- future_map_dfr(1:reps, ~ single_run(beta_1 = 0)) # calculate mean estimates and power for specified alpha sims_fp |&gt; filter(term == &quot;genre_i&quot;) |&gt; summarise(power = mean(p.value &lt; alpha)) ## # A tibble: 1 × 1 ## power ## &lt;dbl&gt; ## 1 0.06 Ideally, the false positive rate will be equal to alpha, which we set at 0.05. 4.6 Power for different effect sizes In real life, we will not know the effect size of our quantity of interest and so we will need to repeatedly perform the power analysis over a range of different plausible effect sizes. Perhaps we might also want to calculate power as we vary other data-generating parameters, such as the number of pop and rock songs sampled and the number of subjects sampled. We can create a table that combines all combinations of the parameters we want to vary in a grid. # grid of paramater values of interest pgrid &lt;- crossing( n_subj = c(10, 25, 50), n_pop = c(10, 40), n_rock = c(10, 40), beta_1 = 1:5 ) We can now wrap our single_run() function within a more general function parameter_search() that takes the grid of parameter values as input and uses the future_pmap_dfr() function to iterate over each row of parameter values in pgrid and feed them into single_run(). # fit the models over the parameters parameter_search &lt;- function(params = pgrid){ future_pmap_dfr( .l = params, # iterate over the grid of parameter values .f = ~ single_run( n_subj = ..1, # plug each row of parameter values into single_run() n_pop = ..2, n_rock = ..3, beta_1 = ..4 ), .options = furrr_options(seed = TRUE), .progress = TRUE ) } If we call parameter_search() it will return a single replication of simulations for each combination of parameter values in pgrid. parameter_search() ## # A tibble: 420 × 8 ## effect group term estimate std.error statistic df p.value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 fixed &lt;NA&gt; (Intercept) 58.3 2.97 19.7 10.4 1.42e- 9 ## 2 fixed &lt;NA&gt; genre_i -0.383 1.98 -0.194 12.9 8.49e- 1 ## 3 ran_pars song_id sd__(Intercep… 2.62 NA NA NA NA ## 4 ran_pars subj_id sd__(Intercep… 8.58 NA NA NA NA ## 5 ran_pars subj_id cor__(Interce… -0.708 NA NA NA NA ## 6 ran_pars subj_id sd__genre_i 3.24 NA NA NA NA ## 7 ran_pars Residual sd__Observati… 8.62 NA NA NA NA ## 8 fixed &lt;NA&gt; (Intercept) 62.8 2.15 29.1 14.6 2.36e-14 ## 9 fixed &lt;NA&gt; genre_i 1.75 2.13 0.820 16.8 4.24e- 1 ## 10 ran_pars song_id sd__(Intercep… 3.52 NA NA NA NA ## # ℹ 410 more rows To run multiple replications of parameter_search(), we can use the future_replicate() function, which just repeatedly calls parameter_search() for the number of times specified by reps. Fair warning, this will take some time if you have set a high number of replications! # replicate the parameter grid to match the dimensions of the model outputs pgrid_expand &lt;- pgrid |&gt; slice(rep(1:n(), each = 7)) |&gt; # replicate each row by 7 parameters map_df(rep.int, times = reps) # replicate the whole grid by number of reps # replicate the parameter search many times sims_params &lt;- future_replicate( n = reps, expr = parameter_search(), simplify = FALSE ) |&gt; imap( ~ mutate(.x, rep = .y, .before = &quot;effect&quot;)) |&gt; # include rep ID bind_rows() |&gt; # combine into a single tibble mutate(pgrid_expand, .before = &quot;effect&quot;) # add in the parameter grid values Now, as before, we can calculate power. But this time we’ll group by all of the parameters we manipulated in pgrid, so that we can get power estimates for all combinations of parameter values. sims_table &lt;- sims_params |&gt; filter(term == &quot;genre_i&quot;) |&gt; group_by(term, n_subj, n_pop, n_rock, beta_1) |&gt; summarise( mean_estimate = mean(estimate), mean_se = mean(std.error), power = mean(p.value &lt; alpha), .groups = &quot;drop&quot; ) Here’s a graph that visualizes the output of the power simulation. sims_table |&gt; mutate(across(n_subj:beta_1, as.factor), n_pop = paste0(&quot;n_pop: &quot;, n_pop), n_rock = paste0(&quot;n_rock: &quot;, n_rock)) |&gt; ggplot(aes(x = mean_estimate, y = power, group = n_subj, color = n_subj)) + geom_hline(yintercept = 0.8, linetype = &quot;dashed&quot;, color = &quot;grey50&quot;, linewidth = 0.5) + geom_line() + geom_point(size = 2) + facet_grid(n_pop ~ n_rock) + ylim(0, 1) + labs(x = &quot;Effect size (rock genre - pop genre)&quot;, y = &quot;Power&quot;, title = &quot;Power analysis via simulation&quot;, color = &quot;Sample size&quot;) + theme_bw() Here’s a nicely formatted table that summarizes the output from the power simulation. sims_table |&gt; gt() |&gt; tab_header(title = &quot;Power analysis via simulation&quot;) |&gt; data_color( columns = power, fn = scales::col_numeric( palette = c(&quot;red&quot;, &quot;green&quot;), domain = c(0, 1) ) ) #peypicwoph table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #peypicwoph thead, #peypicwoph tbody, #peypicwoph tfoot, #peypicwoph tr, #peypicwoph td, #peypicwoph th { border-style: none; } #peypicwoph p { margin: 0; padding: 0; } #peypicwoph .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #peypicwoph .gt_caption { padding-top: 4px; padding-bottom: 4px; } #peypicwoph .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #peypicwoph .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #peypicwoph .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #peypicwoph .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #peypicwoph .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #peypicwoph .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #peypicwoph .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #peypicwoph .gt_column_spanner_outer:first-child { padding-left: 0; } #peypicwoph .gt_column_spanner_outer:last-child { padding-right: 0; } #peypicwoph .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #peypicwoph .gt_spanner_row { border-bottom-style: hidden; } #peypicwoph .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #peypicwoph .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #peypicwoph .gt_from_md > :first-child { margin-top: 0; } #peypicwoph .gt_from_md > :last-child { margin-bottom: 0; } #peypicwoph .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #peypicwoph .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #peypicwoph .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #peypicwoph .gt_row_group_first td { border-top-width: 2px; } #peypicwoph .gt_row_group_first th { border-top-width: 2px; } #peypicwoph .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #peypicwoph .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #peypicwoph .gt_first_summary_row.thick { border-top-width: 2px; } #peypicwoph .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #peypicwoph .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #peypicwoph .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #peypicwoph .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #peypicwoph .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #peypicwoph .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #peypicwoph .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #peypicwoph .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #peypicwoph .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #peypicwoph .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #peypicwoph .gt_left { text-align: left; } #peypicwoph .gt_center { text-align: center; } #peypicwoph .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #peypicwoph .gt_font_normal { font-weight: normal; } #peypicwoph .gt_font_bold { font-weight: bold; } #peypicwoph .gt_font_italic { font-style: italic; } #peypicwoph .gt_super { font-size: 65%; } #peypicwoph .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #peypicwoph .gt_asterisk { font-size: 100%; vertical-align: 0; } #peypicwoph .gt_indent_1 { text-indent: 5px; } #peypicwoph .gt_indent_2 { text-indent: 10px; } #peypicwoph .gt_indent_3 { text-indent: 15px; } #peypicwoph .gt_indent_4 { text-indent: 20px; } #peypicwoph .gt_indent_5 { text-indent: 25px; } Power analysis via simulation term n_subj n_pop n_rock beta_1 mean_estimate mean_se power genre_i 10 10 10 1 0.6821340 2.1433713 0.08 genre_i 10 10 10 2 1.7274589 2.1428328 0.13 genre_i 10 10 10 3 2.7482126 2.1406312 0.20 genre_i 10 10 10 4 3.6963509 2.1395978 0.30 genre_i 10 10 10 5 4.6922276 2.1399928 0.48 genre_i 10 10 40 1 0.7216763 1.8288706 0.06 genre_i 10 10 40 2 1.7059291 1.8322465 0.12 genre_i 10 10 40 3 2.6756674 1.8421354 0.28 genre_i 10 10 40 4 3.7319609 1.8460860 0.48 genre_i 10 10 40 5 4.7424011 1.8396712 0.72 genre_i 10 40 10 1 0.8245941 1.8332649 0.06 genre_i 10 40 10 2 1.8476570 1.8308934 0.14 genre_i 10 40 10 3 2.8841097 1.8234947 0.28 genre_i 10 40 10 4 3.9163802 1.8294477 0.53 genre_i 10 40 10 5 4.9206879 1.8285285 0.72 genre_i 10 40 40 1 1.1213453 1.4790172 0.08 genre_i 10 40 40 2 2.1427686 1.4853951 0.26 genre_i 10 40 40 3 3.1372541 1.4847795 0.47 genre_i 10 40 40 4 4.1692116 1.4875177 0.75 genre_i 10 40 40 5 5.1915115 1.4906076 0.88 genre_i 25 10 10 1 0.6206088 1.7168699 0.05 genre_i 25 10 10 2 1.6084364 1.7200867 0.16 genre_i 25 10 10 3 2.6187355 1.7234279 0.32 genre_i 25 10 10 4 3.6035387 1.7198478 0.47 genre_i 25 10 10 5 4.5822773 1.7152229 0.75 genre_i 25 10 40 1 0.9055907 1.4495982 0.08 genre_i 25 10 40 2 1.8898537 1.4482419 0.21 genre_i 25 10 40 3 2.8874405 1.4451119 0.50 genre_i 25 10 40 4 3.9016062 1.4461335 0.76 genre_i 25 10 40 5 4.8689765 1.4454742 0.90 genre_i 25 40 10 1 1.0219424 1.4336253 0.13 genre_i 25 40 10 2 2.0103972 1.4328662 0.28 genre_i 25 40 10 3 2.9942518 1.4348602 0.49 genre_i 25 40 10 4 4.0128924 1.4346163 0.77 genre_i 25 40 10 5 5.0216769 1.4367684 0.97 genre_i 25 40 40 1 0.9529641 1.0960443 0.17 genre_i 25 40 40 2 1.9357289 1.0964069 0.42 genre_i 25 40 40 3 2.9554635 1.0980187 0.72 genre_i 25 40 40 4 3.9530592 1.0980973 0.90 genre_i 25 40 40 5 4.9797585 1.0980008 0.99 genre_i 50 10 10 1 0.8935373 1.5072281 0.13 genre_i 50 10 10 2 1.8989927 1.5076409 0.20 genre_i 50 10 10 3 2.8976098 1.5096626 0.42 genre_i 50 10 10 4 3.8978394 1.5063429 0.63 genre_i 50 10 10 5 4.9065649 1.5102823 0.90 genre_i 50 10 40 1 0.8624299 1.2642873 0.12 genre_i 50 10 40 2 1.8966771 1.2632430 0.29 genre_i 50 10 40 3 2.9027209 1.2631341 0.60 genre_i 50 10 40 4 3.8651279 1.2660562 0.87 genre_i 50 10 40 5 4.8895942 1.2672331 0.98 genre_i 50 40 10 1 0.9841072 1.2649182 0.16 genre_i 50 40 10 2 1.9939159 1.2657064 0.35 genre_i 50 40 10 3 3.0015429 1.2671451 0.65 genre_i 50 40 10 4 3.9797475 1.2674822 0.84 genre_i 50 40 10 5 4.9817978 1.2696728 0.96 genre_i 50 40 40 1 0.9598020 0.9119584 0.21 genre_i 50 40 40 2 1.9561492 0.9104045 0.54 genre_i 50 40 40 3 2.9585712 0.9104254 0.91 genre_i 50 40 40 4 3.9730888 0.9107474 0.99 genre_i 50 40 40 5 4.9661969 0.9115207 1.00 "],["python.html", "5 Python 5.1 Simple linear regression 5.2 Mixed effects model", " 5 Python 5.1 Simple linear regression 5.1.1 Setup First, let’s import the libraries used for simulation based power analysis in Python. import random import numpy as np import pandas as pd from sklearn.linear_model import LinearRegression import statsmodels.api as sm import scipy import matplotlib.pyplot as plt We will also set the pseudo-random number generator seed to 02138 to make the stochastic components of our simulations reproducible. np.random.seed(02138) 5.1.2 Step 4: Simulate Next, we create a simulated dataset based on our assumptions about the model under the alternative hypothesis, and fit the model. def generate_dataset(sample_size, interact_coef): data_set = [] for i in range(sample_size): _id = i age = np.random.randint(18,66) female = np.random.choice([0, 1]) interact = age * female e = np.random.normal(0, 20) sbp = 110 + 0.5*age + (-20)*female + interact_coef*interact + e data_set.append([_id, age, female, interact, e, sbp]) data_set = pd.DataFrame(data_set) data_set.columns = [&quot;_id&quot;, &quot;age&quot;, &quot;female&quot;, &quot;interact&quot;, &#39;e&#39;, &quot;sbp&quot;] return data_set 5.1.3 Step 5: Automate Next, let’s write a function that creates datasets under the alternative hypothesis, fits the models, and uses a likelihood-ratio test to calculate power. def cal_power(sample_size, interact_coef, simiu_cnt, alpha): power_list = [] for i in range(simiu_cnt): dataset = generate_dataset(sample_size, interact_coef) y1 = dataset[&#39;sbp&#39;] x1 = dataset[[&#39;age&#39;, &#39;female&#39;, &#39;interact&#39;]] x1 = sm.add_constant(x1) full_model = sm.OLS(y1, x1).fit() full_ll = full_model.llf y2 = dataset[&#39;sbp&#39;] x2 = dataset[[&#39;age&#39;, &#39;female&#39;]] x2 = sm.add_constant(x2) reduced_model = sm.OLS(y2, x2).fit() reduced_ll = reduced_model.llf LR_statistic = -2*(reduced_ll-full_ll) power = scipy.stats.chi2.sf(LR_statistic, 1) if power&lt;=alpha: power_list.append(1) else: power_list.append(0) mean_power = sum(power_list)/len(power_list) return [sample_size, interact_coef, mean_power] result = [] for i in range(400, 800, 100): for j in [0.2, 0.25, 0.3, 0.35, 0.4]: result.append(cal_power(sample_size = i, interact_coef = j, simiu_cnt = 1000, alpha = 0.05)) result = pd.DataFrame(result) result.columns = [&#39;N&#39;, &#39;interact_coef&#39;, &#39;Power&#39;] result 5.1.4 Step 6: Summarize In this part, we export the results of the simulations which include two parts: a table and a graph showing the results from the simulations. It should be noted that the graph from Python simulation is a little bit different from that in Stata, and this is mainly caused by different simulation process within Stata and Python. N interact_coef Power 0 400 0.20 0.320 1 400 0.25 0.413 2 400 0.30 0.557 3 400 0.35 0.664 4 400 0.40 0.798 5 500 0.20 0.328 6 500 0.25 0.513 7 500 0.30 0.636 8 500 0.35 0.788 9 500 0.40 0.869 10 600 0.20 0.406 11 600 0.25 0.569 12 600 0.30 0.714 13 600 0.35 0.829 14 600 0.40 0.926 15 700 0.20 0.447 16 700 0.25 0.601 17 700 0.30 0.776 18 700 0.35 0.887 19 700 0.40 0.955 n_list = result[&#39;N&#39;].unique() color_list = [&#39;darkblue&#39;, &#39;firebrick&#39;, &#39;darkgreen&#39;, &#39;orange&#39;] plt.figure(figsize=(15,6)) for i in range(len(n_list)): n = n_list[i] c = color_list[i] plt.plot(result[result[&#39;N&#39;]==n][&#39;interact_coef&#39;], result[result[&#39;N&#39;]==n][&#39;Power&#39;], &#39;o-&#39;, color = c) plt.grid() plt.xticks([0.2, 0.25, 0.3, 0.35, 0.4], fontsize = 12) plt.yticks([0.2, 0.4, 0.6, 0.8, 1], fontsize = 12) plt.xlabel(&#39;interact&#39;, fontsize = 15) plt.ylabel(&#39;Power&#39;, fontsize = 15) plt.legend(result[&#39;N&#39;].unique(), fontsize = 12) plt.title(&#39;Estimate Power: Two-sided Test&#39;, fontsize = 18) plt.show() 5.2 Mixed effects model For the mixed effects model example, we will continue to use the same Python libraries and pseudo-random number generator seed as previously. 5.2.1 Step 4: Simulate Next, we create a simulated dataset based on our assumptions about the model under the alternative hypothesis, and fit the model. We will simulate 5 observations at 4-month increments for 200 children. def generate_dataset(sample_size, obser_cnt): data_set = [] for i in range(sample_size): child_id = i female_origin = np.random.choice([0, 1]) u_0i_origin = np.random.normal(0, 0.25) u_1i_origin = np.random.normal(0, 0.60) for j in range(obser_cnt): child = child_id female = female_origin age = 0.5*j u_0i = u_0i_origin u_1i = u_1i_origin interaction = age * female e_ij = np.random.normal(0, 1.2) weight = 5.35 + 3.6*age + (-0.5)*female + (-0.25)*interaction + u_0i + age*u_1i + e_ij data_set.append([child, female, age, u_0i, u_1i, interaction, e_ij, weight]) data_set = pd.DataFrame(data_set) data_set.columns = [&quot;child_id&quot;, &quot;female&quot;, &quot;age&quot;, &quot;u_0i&quot;, &quot;u_li&quot;, &quot;interaction&quot;, &quot;e_ij&quot;, &quot;weight&quot;] return data_set 5.2.2 Step 5: Automate Next, let’s write a function that creates datasets under the alternative hypothesis, fits the mixed effects models, tests the null hypothesis of interest, and uses a for loop to run many iterations of the function. def cal_power(sample_size, obser_cnt, simiu_cnt, alpha): power_list = [] for i in range(simiu_cnt): dataset = generate_dataset(sample_size, obser_cnt) y1 = dataset[&#39;weight&#39;] x1 = dataset[[&#39;female&#39;, &#39;age&#39;, &#39;interaction&#39;]] x1 = sm.add_constant(x1) full_model = sm.OLS(y1, x1).fit() full_ll = full_model.llf y2 = dataset[&#39;weight&#39;] x2 = dataset[[&#39;female&#39;, &#39;age&#39;]] x2 = sm.add_constant(x2) reduced_model = sm.OLS(y2, x2).fit() reduced_ll = reduced_model.llf LR_statistic = -2*(reduced_ll-full_ll) power = scipy.stats.chi2.sf(LR_statistic, 1) if power&lt;=alpha: power_list.append(1) else: power_list.append(0) mean_power = sum(power_list)/len(power_list) return [obser_cnt, sample_size, mean_power] result = [] for i in range(100, 600, 100): for j in range(5, 7): result.append(cal_power(sample_size = i, obser_cnt = j, simiu_cnt = 1000, alpha = 0.05)) result = pd.DataFrame(result) result.columns = [&#39;n1&#39;, &#39;N&#39;, &#39;Power&#39;] result 5.2.3 Step 6: Summarize The last procedure is to export the results which contain a table and a graph. n1 N Power 0 5 100 0.290 1 6 100 0.398 2 5 200 0.491 3 6 200 0.632 4 5 300 0.655 5 6 300 0.798 6 5 400 0.779 7 6 400 0.917 8 5 500 0.857 9 6 500 0.940 n1_list = result[&#39;n1&#39;].unique() color_list = [&#39;darkblue&#39;, &#39;firebrick&#39;] plt.figure(figsize=(15,6)) for i in range(len(n1_list)): n = n1_list[i] c = color_list[i] plt.plot(result[result[&#39;n1&#39;]==n][&#39;N&#39;], result[result[&#39;n1&#39;]==n][&#39;Power&#39;], &#39;-o&#39;, color = c) plt.grid() plt.xticks([100, 200, 300, 400, 500], fontsize = 12) plt.yticks([0.2, 0.4, 0.6, 0.8, 1], fontsize = 12) plt.xlabel(&#39;Level 2 Sample Size&#39;, fontsize = 15) plt.ylabel(&#39;Power&#39;, fontsize = 15) plt.legend(result[&#39;n1&#39;].unique(), fontsize = 12) plt.title(&#39;Power: Two-sided Test&#39;, fontsize = 18) plt.show() "],["stata.html", "6 Stata 6.1 Simple linear regression 6.2 Mixed effects model", " 6 Stata 6.1 Simple linear regression 6.1.1 Setup We will also set the pseudo-random number generator seed to 02138 to make the stochastic components of our simulations reproducible. set seed 02138 6.1.2 Step 4: Simulate Next, we create a simulated dataset based on our assumptions about the model under the alternative hypothesis, and fit the model. clear set obs 400 generate age = runiformint(18,65) generate female = rbinomial(1,0.5) generate interact = age*female generate e = rnormal(0,20) generate sbp = 110 + 0.5*age + (-20)*female + 0.35*interact + e We can then test the null hypothesis that the interaction term equals zero using a likelihood-ratio test. regress sbp age i.female c.age#i.female estimates store full regress sbp age i.female estimates store reduced Likelihood-ratio test LR chi2(1) = 13.38 (Assumption: reduced nested in full) Prob &gt; chi2 = 0.0003 The test yields a p-value of 0.0003. return list scalars: r(p) = .0002540647000293 r(chi2) = 13.38189649447986 r(df) = 1 local reject = (r(p)&lt;0.05) 6.1.3 Step 5: Automate Next, let’s write a program that creates datasets under the alternative hypothesis, fits the models, and uses the simulate command to test the program. capture program drop simregress program simregress, rclass version 16 // DEFINE THE INPUT PARAMETERS AND THEIR DEFAULT VALUES syntax, n(integer) /// Sample size [ alpha(real 0.05) /// Alpha level intercept(real 110) /// Intercept parameter age(real 0.5) /// Age parameter female(real -20) /// Female parameter interact(real 0.35) /// Interaction parameter esd(real 20) ] // Standard deviation of the error quietly { // GENERATE THE RANDOM DATA clear set obs `n&#39; generate age = runiformint(18,65) generate female = rbinomial(1,0.5) generate interact = age*female generate e = rnormal(0,`esd&#39;) generate sbp = `intercept&#39; + `age&#39;*age + `female&#39;*female + /// `interact&#39;*interact + e // TEST THE NULL HYPOTHESIS regress sbp age i.female c.age#i.female estimates store full regress sbp age i.female estimates store reduced lrtest full reduced } // RETURN RESULTS return scalar reject = (r(p)&lt;`alpha&#39;) end Below, we use simulate to run simregress 200 times and summarize the variable reject. The results indicate that we would have 74% power to detect an interaction parameter of 0.35 given a sample of 400 participants and the other assumptions about the model. simulate reject=r(reject), reps(200) seed(12345): /// simttest, n(200) m0(70) ma(75) sd(15) alpha(0.05) Simulations (200) ----+--- 1 ---+--- 2 ---+--- 3 ---+--- 4 ---+--- 5 .................................................. 50 .................................................. 100 .................................................. 150 .................................................. 200 summarize reject Variable | Obs Mean Std. dev. Min Max -------------+--------------------------------------------------------- reject | 200 .735 .4424407 0 1 Next, let’s write a program called power\\_cmd\\_simregress so that we can integrate simregress into Stata’s power command. capture program drop power_cmd_simregress program power_cmd_simregress, rclass version 17 // DEFINE THE INPUT PARAMETERS AND THEIR DEFAULT VALUES syntax, n(integer) /// Sample size [ alpha(real 0.05) /// Alpha level intercept(real 110) /// Intercept parameter age(real 0.5) /// Age parameter female(real -20) /// Female parameter interact(real 0.35) /// Interaction parameter esd(real 20) /// Standard deviation of the error reps(integer 100)] // Number of repetitions // GENERATE THE RANDOM DATA AND TEST THE NULL HYPOTHESIS quietly { simulate reject=r(reject), reps(`reps&#39;): /// simregress, n(`n&#39;) age(`age&#39;) female(`female&#39;) /// interact(`interact&#39;) esd(`esd&#39;) alpha(`alpha&#39;) summarize reject } // RETURN RESULTS return scalar power = r(mean) return scalar N = `n&#39; return scalar alpha = `alpha&#39; return scalar intercept = `intercept&#39; return scalar age = `age&#39; return scalar female = `female&#39; return scalar interact = `interact&#39; return scalar esd = `esd&#39; end Finally, run power simregress for a range of input parameter values, including the parameters listed in double quotes. To do this, we first need to create a program called power\\_cmd\\_simregress\\_init. capture program drop power_cmd_simregress_init program power_cmd_simregress_init, sclass sreturn local pss_colnames &quot;intercept age female interact esd&quot; sreturn local pss_numopts &quot;intercept age female interact esd&quot; end 6.1.4 Step 6: Summarize Now, we’re ready to use power simregress! The output below shows the simulated power when the interaction parameter equals 0.2 to 0.4 in increments of 0.05 for samples of size 400, 500, 600, and 700. power simregress, n(400(100)700) intercept(110) /// age(0.5) female(-20) interact(0.2(0.05)0.4) /// reps(1000) table graph(xdimension(interact) /// legend(rows(1))) Estimated power Two-sided test +--------------------------------------------------------------------+ | alpha power N intercept age female interact esd | |--------------------------------------------------------------------| | .05 .3 400 110 .5 -20 .2 20 | | .05 .421 400 110 .5 -20 .25 20 | | .05 .546 400 110 .5 -20 .3 20 | | .05 .685 400 110 .5 -20 .35 20 | | .05 .767 400 110 .5 -20 .4 20 | | .05 .34 500 110 .5 -20 .2 20 | | .05 .509 500 110 .5 -20 .25 20 | | .05 .63 500 110 .5 -20 .3 20 | | .05 .767 500 110 .5 -20 .35 20 | | .05 .872 500 110 .5 -20 .4 20 | | .05 .412 600 110 .5 -20 .2 20 | | .05 .556 600 110 .5 -20 .25 20 | | .05 .712 600 110 .5 -20 .3 20 | | .05 .829 600 110 .5 -20 .35 20 | | .05 .886 600 110 .5 -20 .4 20 | | .05 .471 700 110 .5 -20 .2 20 | | .05 .634 700 110 .5 -20 .25 20 | | .05 .771 700 110 .5 -20 .3 20 | | .05 .908 700 110 .5 -20 .35 20 | | .05 .957 700 110 .5 -20 .4 20 | +--------------------------------------------------------------------+ 6.2 Mixed effects model 6.2.1 Setup Again, we set the seed to 02138. set seed 02138 6.2.2 Step 4: Simulate Next, we create a simulated dataset based on our assumptions about the model under the alternative hypothesis, and fit the model. We will simulate 5 observations at 4-month increments for 200 children. clear set obs 200 generate child = _n generate female = rbinomial(1,0.5) generate u_0i = rnormal(0,0.25) generate u_1i = rnormal(0,0.60) expand 5 bysort child: generate age = (_n-1)*0.5 generate interaction = age*female generate e_ij = rnormal(0,1.2) generate weight = 5.35 + 3.6*age + (-0.5)*female + (-0.25)*interaction /// + u_0i + age*u_1i + e_ij Our dataset includes the random deviations that we would not observe in a real dataset. We can then use mixed to fit a model to our simulated data. mixed weight age i.female c.age#i.female || child: age , stddev nolog noheader estimates store full mixed weight age i.female || child: age , stddev nolog noheader estimates store reduced lrtest full reduced We can then test the null hypothesis that the interaction term equals zero using a likelihood-ratio test. lrtest full reduced Likelihood-ratio test LR chi2(1) = 8.23 (Assumption: reduced nested in full) Prob &gt; chi2 = 0.0041 The \\(p\\)-value for our test is 0.0041, so we would reject the null hypothesis that the interaction term equals zero. 6.2.3 Step 5: Automate Next, let’s write a program that creates datasets under the alternative hypothesis, fits the mixed effects models, tests the null hypothesis of interest, and uses the simulate command to run many iterations of the program. capture program drop simmixed program simmixed, rclass version 16 // PARSE INPUT syntax, n1(integer) /// n(integer) /// [ alpha(real 0.05) /// intercept(real 5.35) /// age(real 3.6) /// female(real -0.5) /// interact(real -0.25) /// u0i(real 0.25) /// u1i(real 0.60) /// eij(real 1.2) ] // COMPUTE POWER quietly { drop _all set obs `n&#39; generate child = _n generate female = rbinomial(1,0.5) generate u_0i = rnormal(0,`u0i&#39;) generate u_1i = rnormal(0,`u1i&#39;) expand `n1&#39; bysort child: generate age = (_n-1)*0.5 generate interaction = age*female generate e_ij = rnormal(0,`eij&#39;) generate weight = `intercept&#39; + `age&#39;*age + `female&#39;*female + /// `interact&#39;*interaction + u_0i + age*u_1i + e_ij mixed weight age i.female c.age#i.female || child: age, iter(200) local conv1 = e(converged) estimates store full mixed weight age i.female || child: age, iter(200) local conv2 = e(converged) estimates store reduced lrtest full reduced local reject = cond(`conv1&#39; + `conv2&#39;==2, (r(p)&lt;`alpha&#39;), .) } // RETURN RESULTS return scalar reject = `reject&#39; return scalar conv = `conv1&#39;+`conv2&#39; end We then use simulate to run simmixed 10 times using the default parameter values for 5 observations on each of 200 children. simulate reject=r(reject) converged=r(conv), reps(10) seed(12345): simmixed, n1(5) n(200) command: simmixed, n1(5) n(200) reject: r(reject) converged: r(conv) Simulations (10) ----+--- 1 ---+--- 2 ---+--- 3 ---+--- 4 ---+--- 5 simulate saved the results of the hypothesis tests to a variable named reject. The mean of reject is our estimate of the power to test the null hypothesis that the age×sex interaction term equals zero, assuming that the weight of 200 children is measured 5 times. We could stop with our quick simulation if we were interested only in a specific set of assumptions. But it’s easy to write an additional program named power\\_cmd\\_simmixed that will allow us to use Stata’s power command to create tables and graphs for a range of sample sizes. capture program drop power_cmd_simmixed program power_cmd_simmixed, rclass version 16 // PARSE INPUT syntax, n1(integer) /// n(integer) /// [ alpha(real 0.05) /// intercept(real 5.35) /// age(real 3.6) /// female(real -0.5) /// interact(real -0.25) /// u0i(real 0.25) /// u1i(real 0.60) /// eij(real 1.2) /// reps(integer 1000) ] // COMPUTE POWER quietly { simulate reject=r(reject), reps(`reps&#39;): /// simmixed, n1(`n1&#39;) n(`n&#39;) alpha(`alpha&#39;) intercept(`intercept&#39;) /// age(`age&#39;) female(`female&#39;) interact(`interact&#39;) /// u0i(`u0i&#39;) u1i(`u1i&#39;) eij(`eij&#39;) summarize reject } // RETURN RESULTS return scalar power = r(mean) return scalar n1 = `n1&#39; return scalar N = `n&#39; return scalar alpha = `alpha&#39; return scalar intercept = `intercept&#39; return scalar age = `age&#39; return scalar female = `female&#39; return scalar interact = `interact&#39; return scalar u0i = `u0i&#39; return scalar u1i = `u1i&#39; return scalar eij = `eij&#39; end It’s also easy to write a program named power\\_cmd\\_simmixed\\_init that will allow us to simulate power for a range of values for the parameters in our model. capture program drop power_cmd_simmixed_init program power_cmd_simmixed_init, sclass version 16 sreturn clear // ADD COLUMNS TO THE OUTPUT TABLE sreturn local pss_colnames &quot;n1 intercept age female interact u0i u1i eij&quot; // ALLOW NUMLISTS FOR ALL PARAMETERS sreturn local pss_numopts &quot;n1 intercept age female interact u0i u1i eij&quot; end 6.2.4 Step 6: Summarize Now, we can use power simmixed to simulate power for a variety of assumptions. The example below simulates power for a range of sample sizes at both levels 1 and 2. Level 2 sample sizes range from 100 to 500 children in increments of 100. At level 1, we consider 5 and 6 observations per child. power simmixed, n1(5 6) n(100(100)500) reps(1000) table(n1 N power) graph(ydimension(power) xdimension(N) plotdimension(n1) xtitle(Level 2 Sample Size) legend(title(Level 1 Sample Size))) xxxxxxxxxxxxxxxxxxxxxxxxxxx Estimated power Two-sided test +-------------------------+ | n1 N power | |-------------------------| | 5 100 .2629 | | 6 100 .313 | | 5 200 .397 | | 6 200 .569 | | 5 300 .621 | | 6 300 .735 | | 5 400 .734 | | 6 400 .855 | | 5 500 .828 | | 6 500 .917 | +-------------------------+ "],["software-comparison.html", "7 Software Comparison", " 7 Software Comparison "],["resources.html", "Resources", " Resources We would like to acknowledge some excellent online and peer-reviewed material about power simulation and mixed effects models, which we have borrowed from liberally in the tutorial. These resouces represent an excellent next step in your exploration of simulation-based power analysis. R DeBruine &amp; Barr (2021) paper on using simulation to understand mixed effects models: https://journals.sagepub.com/doi/epdf/10.1177/2515245920965119 Kumle et al. (2021) paper on estimating power in GLMMs: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8613146/ Julian Quandt’s 4-part blog series on power analysis via simulation: https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-i/ https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-ii/ https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-iii/ https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-iv/ Stata Chuck Huber’s 4-part blog series on power analysis via simulation: https://blog.stata.com/2019/01/10/calculating-power-using-monte-carlo-simulations-part-1-the-basics/ https://blog.stata.com/2019/01/29/calculating-power-using-monte-carlo-simulations-part-2-running-your-simulation-using-power/ https://blog.stata.com/2019/08/13/calculating-power-using-monte-carlo-simulations-part-3-linear-and-logistic-regression/ https://blog.stata.com/2019/08/20/calculating-power-using-monte-carlo-simulations-part-4-multilevel-longitudinal-models/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
